# 《计算机程序的结构和解释》的前言，1984年

教育家、将军、营养师、心理学家和父母都在进行编程。军队、学生和一些社会也在被编程。攻克重大问题需要一系列的程序，其中大部分在途中产生。这些程序充斥着看似与手头问题有关的问题。要欣赏编程作为一种独立的智力活动，您必须转向计算机编程；您必须阅读和编写计算机程序 - 很多程序。这些程序的主题和应用并不重要，重要的是它们的执行效果以及它们如何与其他程序无缝地配合，创造出更大的程序。程序员必须追求部分的完美和整体的充分。在本书中，“程序”的使用主要集中在使用Lisp方言编写、执行和研究数字计算机上的程序。使用Lisp，我们限制的不是我们可以编程的内容，而只是我们对程序描述的符号表示。

这本书所涉及的主题使我们与三个现象焦点产生了交集：人类思维、计算机程序的集合和计算机本身。每个计算机程序都是一种模型，孕育于思维之中，模拟了真实或心理过程。这些过程源自人类的经验和思考，其数量庞大，细节复杂，而且任何时候只能部分理解。我们的计算机程序很少能完美地模拟这些过程，因此它们不断演化：随着我们对模型的认识加深、扩大和普遍化，我们会对它们进行修改，直到最终在我们努力奋斗的另一个模型中获得一个亚稳定的位置。与计算机编程相关的激动源于思维和计算机中以程序形式表达的机制的不断展开，以及它们所引发的感知的爆发。如果艺术解释我们的梦境，那么计算机以程序的形式执行它们！

尽管计算机具有强大的能力，但它也是一个严苛的任务主人。它的程序必须是正确的，我们所希望表达的内容必须在每一个细节上准确无误地表达出来。与其他符号活动一样，我们通过论证来确信程序的正确性。Lisp本身可以被赋予语义（顺便说一句，这是另一个模型），如果一个程序的功能可以在谓词演算中进行规定，那么逻辑的证明方法可以用来进行可接受的正确性论证。不幸的是，随着程序变得庞大和复杂（这几乎总是会发生的），规范的充分性、一致性和正确性本身变得值得怀疑，因此完整的形式正确性论证很少伴随着大型程序。由于大型程序是由小型程序逐渐发展而来的，因此我们必须建立起一套标准的程序结构库，确保它们的正确性 - 我们称之为惯用法，并学会使用经过验证的组织技术将它们组合成更大的结构。这些技术在本书中得到详细介绍，理解它们对参与称为编程的普罗米修斯事业至关重要。最重要的是，揭示和掌握强大的组织技术加速了我们创建大型、重要程序的能力。相反，由于编写大型程序非常费力，我们被激发出发明新的方法来减少要适应大型程序的功能和细节的负担。与程序不同，计算机必须遵守物理定律。如果它们希望执行得很快 - 每个状态变化几纳秒 - 它们必须只传输电子的小距离（最多1.5英尺）。由于这么多设备在空间中集中，产生的热量必须被移除。一种精妙的工程艺术已经发展起来，在功能的多样性和设备的密度之间取得平衡。无论如何，硬件始终在比我们关心的编程层次更原始的层次上运行。将我们的Lisp程序转换为“机器”程序的过程本身就是我们编程的抽象模型。对它们的研究和创建使我们对与编程任意模型相关的组织程序有了深入的了解。当然，计算机本身也可以被建模。想象一下：最小的物理开关元件的行为由量子力学建模，由微分方程描述，其详细行为由在计算机上执行的数值逼近在计算机上表示...！

将这三个焦点分开并不仅仅是战术上的便利。尽管如他们所说，这一切都在头脑中，但这种逻辑上的分离引发了这些焦点之间的符号交流加速，其丰富性、活力和潜力仅被生命本身的演化所超越。最好的情况是，这些焦点之间的关系是亚稳态的。计算机永远不够大，也不够快。每一次硬件技术的突破都会导致更庞大的编程项目、新的组织原则和抽象模型的丰富。每个读者都应该定期问自己：“为了什么目的，为了什么目的？”但不要问得太频繁，以免错过编程的乐趣而沉湎于苦涩的哲学中。

我们编写的程序中，有些（但从来不够）执行精确的数学功能，比如排序或找到一系列数字的最大值，确定素数或找到平方根。我们将这类程序称为算法，对它们的最优行为，特别是执行时间和数据存储需求这两个重要参数，已经有了很多了解。程序员应该掌握良好的算法和惯用法。尽管有些程序难以精确规定，但程序员有责任估计并始终努力改进它们的性能。
Lisp是一个幸存者，已经使用了大约四分之一个世纪。在活跃的编程语言中，只有Fortran的寿命更长。这两种语言都支持重要应用领域的编程需求，Fortran用于科学和工程计算，Lisp用于人工智能。这两个领域仍然非常重要，它们的程序员对这两种语言非常热衷，因此Lisp和Fortran很可能在至少未来的四分之一个世纪内继续得到广泛使用。

Lisp发生了变化。在这段文字中使用的Scheme方言已经从原始的Lisp发展而来，在几个重要方面与后者有所不同，包括变量绑定的静态作用域和允许函数作为值返回函数。在语义结构上，Scheme与Algol 60和早期的Lisp非常相似。Algol 60永远不会再成为一种活跃的语言，但它在Scheme和Pascal的基因中延续下来。很难找到两种语言，它们代表了两种文化之间更不同的交流媒介，这两种文化围绕着这两种语言展开。Pascal用于构建金字塔——壮丽、令人叹为观止的静态结构，由推动沉重方块的军队建造而成。Lisp用于构建有机体——壮丽、令人叹为观止的动态结构，由适应变化的无数简单有机体的小队建造而成。在这两种情况下使用的组织原则是相同的，除了一个非常重要的区别：赋予个体Lisp程序员的自由可导出功能远远超过Pascal企业中的功能。Lisp程序通过充实库函数来提升其效用，这些函数的效用超越了产生它们的应用程序。列表，Lisp的本机数据结构，在这种效用的增长中起到了很大的作用。列表的简单结构和自然适用性在函数中得到了非常非特异性的反映。在Pascal中，可声明的数据结构的众多导致函数内部的专业化，抑制和惩罚了随意的合作。与其让10个函数操作10个数据结构，不如让100个函数操作一个数据结构。结果是金字塔必须在千年间保持不变；有机体必须进化或灭亡。

为了说明这种差异，将本书中对材料和练习的处理与使用Pascal的任何第一课程教材进行比较。不要抱着这是一本只有在MIT才能理解的书的幻想，这本书并不是特定于那里的人群。无论学生是谁，无论在哪里使用，这本严肃的Lisp编程书都应该是这样的。
请注意，这是一本关于编程的书，不同于大多数Lisp书籍，后者通常用作人工智能工作的准备。毕竟，软件工程和人工智能的关键编程问题往往在研究的系统变得更大时融合在一起。这解释了为什么人们在人工智能以外对Lisp越来越感兴趣。

正如人们对其目标的期望，人工智能研究产生了许多重要的编程问题。在其他编程文化中，这些问题的大量出现催生了新的编程语言。事实上，在任何非常庞大的编程任务中，一个有用的组织原则是通过发明语言来控制和隔离任务模块内的交互。随着接近系统边界，人类最常进行交互的地方，这些语言往往变得不那么原始。因此，这些系统包含了许多次复制的复杂语言处理函数。Lisp具有如此简单的语法和语义，以至于解析可以被视为一项基本任务。因此，在Lisp程序中几乎没有解析技术的角色，语言处理器的构建很少阻碍大型Lisp系统的增长和变化速度。最后，正是这种语法和语义的简单性承载了所有Lisp程序员的负担和自由。任何超过几行的Lisp程序都无法编写，而不充斥着自由函数。发明和适应；经历困境并重新发明！我们向将自己的思想写在括号嵌套中的Lisp程序员祝酒。

> \- Alan J. Perlis, New Haven, Connecticut